==Introduction to User Authentication

Password-protected actions are a common feature in most web applications, only allowing registered users in with a valid password. This is called “User Authentication”, and many Rails applications need it. Let’s start with a quick scenario of how the user authentication process works.

Signup: create a new user. This user is going to register with a username, password (which will be encrypted in the database), email, etc.
Login: allow a user to sign in with her/his valid username and password. The authentication process happens by matching the username and password in the database, allowing the user access to the protected actions only if the given information matches the recorded values successfully. If not, the user will be redirected to the login page again.
Access Restriction: create a session to hold the authenticated user ID after login, so navigation through additional protected actions can be done easily by just checking the userID in the current session.
Logout: allow the user to sign out and set the authenticated userID in session file to nil.


==Generate User Model & Controller

First, let’s create our application named User_Auth. We’re using mysql as our database:

$ rails new User_Auth -d mysql

Navigate to the application directory in your terminal and generate the User Model and Controller. The controller will get a new method as a parameter.


$ rails cd ./User_Auth
$ rails g model user
$ rails g controller users new

==Setup the Database

Now we need to create a Users table in the database. As you probably know, that is just a simple migration away.


class CreateUsers < ActiveRecord::Migration
  def change
    create_table :users do |t|
      t.string :username 
      t.string :email
      t.string :encrypted_password 
      t.string :salt
      t.timestamps
    end
  end
end

We’ve added 4 columns in the Users table (username, email, encrypted_password & salt) Remember that we never store passwords in plain text, always encrypting the value first before saving it to the database. There are different types of encryption techniques, which we’re are going to look at later in this tutorial.



==Creating the New User Action

Next, let’s write the new and create actions in the UsersController.

class UsersController < ApplicationController  
  def new
    @user = User.new 
  end
  def create
    @user = User.new(params[:user])
    if @user.save
      flash[:notice] = "You signed up successfully"
      flash[:color]= "valid"
    else
      flash[:notice] = "Form is invalid"
      flash[:color]= "invalid"
    end
    render "new"
  end
end

We’ve created two main actions:

- new: simply create a new user object to be rendered in the new template (we’ll see it soon ). The template includes a sign up form. The data in this form will be sent to the create action, described next…
- create: creates the user based on the parameters passed from the new template and saves it to the database. If the user is created successfully, redirect the user to wherever you choose after the signup action. Here we place “You signed up successfully” in the flash hash to indicate success, otherwise render the new template again.




==Sign-up Form template

<% @page_title = "UserAuth | Signup" %>
<div class="Sign_Form">
  <h1>Sign Up</h1>
  <%= form_for(:user, :url => {:controller => 'users', :action => 'create'}) do |f| %>
    <p> Username:</br> <%= f.text_field :username%> </p>
    <p> Email:</br> <%= f.text_field :email%> </p>
    <p> Password:</br> <%= f.password_field :password%></p>
    <p> Password Confirmation:</br> <%= f.password_field :password_confirmation%> </p>
    <%= f.submit :Signup %>
  <% end %>
  <% if @user.errors.any? %>
    <ul class="Signup_Errors">
    <% for message_error in @user.errors.full_messages %>
      <li>* <%= message_error %></li>
    <% end %>
    </ul>
  <% end %>
</div>

Here, we’ve created a form for signup which takes a username, email, password and confirmation password from the user. These values will be sent it as params[:user] to the create action. The  if statement checks for errors in case the user enters invalid data.
You also might have noticed that the signup form has two fields: password and password_confirmation that must match a user in database. We should add attr_accessor methods in the user model to handle these.




==Adding Some Validations to the User Model

In addition to attr_accessors, we need to add some validation rules to make sure that the input data fits our requirements.


class User < ActiveRecord::Base
  attr_accessor :password
  EMAIL_REGEX = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$/i
  validates :username, :presence => true, :uniqueness => true, :length => { :in => 3..20 }
  validates :email, :presence => true, :uniqueness => true, :format => EMAIL_REGEX
  validates :password, :confirmation => true #password_confirmation attr
  validates_length_of :password, :in => 6..20, :on => :create
end

We’ve created a signup page that creates a new user and validates the input data, but we didn’t encrypte the password. Before we do that, let’s talk about password encryption.


==Password Encryption Techniques

As previously mentioned, never store passwords in the database as plain text. Encrypting passwords is a best practice and fundamental to all user authentication approaches in Rails.

Hashing Password

Hashing is the process of applying mathematical functions and algorithms to a string of data to produce a unique output string. While creating a new user, the plain text password gets hashed then saved into the database. When the user signs in, the input password gets hashed and compared with the hashed password stored in the database. This technique is called one-way encryption, meaning, the same inputs with the same hashing function will always give the same output.

We can implement a hashed method using SHA1 in Rails with just two lines of code

require 'digest/sha1'
encrypted_password= Digest::SHA1.hexdigest(password)

Salting Password

Due to some drawbacks that exist in the hashing password technique, like Rainbow tables, salting a password is a more secure way to encrypt passwords. ‘Salt’ is an additional string of data added to the password before encrypting it. It should be unique and random, to render the Rainbow tables flaw useless.

Encryption using salt:


salt= Digest::SHA1.hexdigest("# We add {email} as unique value and #{Time.now} as random value")
encrypted_password= Digest::SHA1.hexdigest("Adding #{salt} to {password}")


Bcrypt

There’s another easy way to encrypt passwords rather than making a salt from scratch: use bcrypt. bcrypt-ruby is a ruby gem for encryption and we’ll use it in our application.

To install it, just add the following into gem file:

gem 'bcrypt-ruby', :require => 'bcrypt' 


and inside your application directory run:

$ bundle install 

then you can simply write:

salt = BCrypt::Engine.generate_salt
encrypted_password = BCrypt::Engine.hash_secret(password, salt)



==Callbacks

We need two functions: one to encrypt the actual password (plain text) before saving the user record and the other function to assign the password attr_accessor to nil. As we have already encrypted and stored password in the database, we will not use it anymore, and we can do this using the before_save and after_save callbacks.

Now, let’s add these functions and callbacks to the user model

before_save :encrypt_password
after_save :clear_password
def encrypt_password
  if password.present?
    self.salt = BCrypt::Engine.generate_salt
    self.encrypted_password= BCrypt::Engine.hash_secret(password, salt)
  end
end
def clear_password
  self.password = nil
end


==Mass Assignment Protection

One of the most common security issues in Rails is called the “mass assignment vulnerability”, and it stems from the ActiveRecord convention of creating getters and setters for all the attribute values of an ActiveRecord object.

In the create action, rather than directly assign each attribute one by one, we use a hash of all the values that we want to assign to the attributes of subject. This is the aforementioned mass assignment and is the crux of the issue. There are attributes we do not want the user to be able to change via the form, but we aren’t checking the parameters.

To avoid it, there’s two methods in Rails to protect attributes from mass assignment

attr_protected: all attributes marked with attr_protected are ignored during mass assignment and all other attributes will be accessible.
attr_accessible: all attributes marekd with attr_accessible are accessible during mass assignment and all other attributes will be protected.
Finally let’s add the accessible attributes into user model

1
attr_accessible :username, :email, :password, :password_confirmation



